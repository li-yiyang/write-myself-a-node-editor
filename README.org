#+title: Make Myself A Node Editor
#+author: 凉凉
* About
记录一下使用 ClojureScript 和 Reagent 来制作一个节点编辑器的过程.
方便之后去进行回看代码. 同时也尝试一下在更加复杂的工作环境下,
使用 org-mode 进行文学编程的可能性.

未来可能会更新到博客里面. (在写了)

(该项目本来应该用在 iGEM 里面的. )

** 可能会使用到的技术栈
+ git (我将尝试使用 [[https://magit.vc][magit]] 来进行辅助)
+ [[https://clojurescript.org][ClojureScript]] (实际上是将 [[https://clojure.org][Clojure]] 编译成 JavaScript 的实现)
+ [[https://reagent-project.github.io][Reagent]], 是 [[https://react.dev][React]] 的 ClojureScript 的绑定
+ [[https://github.com/day8/re-frame][Re-frame]], 一个类似于简化 Reagent 设计的一个框架.
+ [[https://github.com/thheller/shadow-cljs][shadow-cljs]], 用于配置和与 npm 进行沟通
+ [[https://www.electronjs.org][Electron]], 一个类似于将网页作为本地软件的一个框架
  (如果说难听点, 就是 chromium 内核. )

** 目标和计划
+梦里啥都有...+

+ 做一个能够自定义节点类和边类, 自定义节点图标的一个节点编辑器 (Electron)
+ 节点可以执行任意代码作为后端实现, 不是局限于 Clojure (Electron)

* Stage 0
一个 "你就说它能不能动吧" 的开头.

(可以到本项目的 [[https://github.com/li-yiyang/write-myself-a-node-editor/tree/initialized-the-project][initialized-the-project]] 分支查看)

实际上其中大部分都是些辛苦的体力活, 没什么高级的地方.
一些约定:

#+begin_src shell
  > tree . -I "node_modules"
  .
  |-- LICENSE                     ; MIT 协议
  |-- README.org                  ; 本文档
  |-- package-lock.json
  |-- package.json                ; npm 配置
  |-- rescources                  ; 导出的目录
  |   `-- public
  |       `-- index.html
  |-- shadow-cljs.edn             ; shadow-cljs 依赖
  `-- src
      `-- app
          |-- main                ; electron 部分
          |   `-- core.cljs
          `-- renderer            ; 页面部分 (主体)
              |-- core.cljs
              |-- db.cljs
              |-- events.cljs
              |-- subs.cljs
              `-- view.cljs
#+end_src

* Stage 1 - Models and Views
** Overview
在 =app.renderer.core= 的 Namespace 下,
描述 =start!= 的逻辑:

#+begin_src clojure :tangle src/app/renderer/core.cljs
  (ns app.renderer.core
    (:require [reagent.dom         :as reagentdom  :refer [render]]
              [re-frame.core       :as re-frame    :refer [dispatch-sync]]
              [app.renderer.view   :as view        :refer [main]]
              [app.renderer.db     :as db]
              [app.renderer.subs   :as subs]
              [app.renderer.events :as events]
              [devtools.core       :as devtools]
              ))

  (defn ^:dev/after-load start! "Start Renderer" []
    (enable-console-print!)               ; for dev usage
    (devtools/install!)
    (dispatch-sync [:initialize-db])
    (render [main] (.getElementById js/document "app-container")))
#+end_src

其中 =start!= 的逻辑:
+ 为了调试方便, 打开了在游览器终端中输出信息的功能;
+ 初始化数据库;
+ 将 =view/main= 渲染进 id 为 =app-container= 的 HTML 元素中. 

** database and subscription
在 =app.renderer.db= 的 Namespace 下,
定义一个 (带有一些示例的) 数据库. 

#+name: stage-1-db
#+begin_src clojure :tangle src/app/renderer/db.cljs
  (ns app.renderer.db)

  (def default-db
    {     
     :node-class {
                  :Number {
                           :class :Number
                           :param [ :num ]
                           :in    []
                           :out   [ :val ]
                           :func  (fn [{:keys [num]}] { :val num })
                           }
                  :Add    {
                           :class :Add
                           :param []
                           :in    [ :a :b ]
                           :out   [ :val ]
                           :func  (fn [{:keys [a b]}] { :val (+ a b) })
                           }
                  }})
#+end_src

说明:
+ 为什么将 =db.cljs= 和 =subs.cljs= 进行分离?

  +因为抄的教程是这么说的+

  因为之后我像尝试一下图数据库作为数据库后端而不是这种 map 数据类型来作为后端.
  总感觉这样的数据后端在数据量大了之后会吃不消. 
+ 数据库中包含的对象 =node-class=

使用 =app.renderer.subs= 将数据库中的信息暴露给其他模块调用

#+begin_src clojure :tangle src/app/renderer/subs.cljs
  (ns app.renderer.subs
    (:require [re-frame.core :as re-frame :refer [reg-sub]]))
#+end_src

+ =node-class= 使得能够访问所有的节点类

  #+begin_src clojure :tangle src/app/renderer/subs.cljs
    (reg-sub :node-class (fn [db] (db :node-class)))
  #+end_src
+ =classes= 所有节点的名称

  #+begin_src clojure :tangle src/app/renderer/subs.cljs
    (reg-sub :classes (fn [db] (keys (db :node-class))))
  #+end_src

** view
在 =app.renderer.view= 的 Namespace 下,
调用 =reagent=, =re-frame= 的库, 引用:
+ =reagent/atom= 用于使用 =atom= 作为容器存放可记录的数据,
  在被更改的时候会使得 Reagent 刷新页面.
+ =reagent/cursor= 和 =atom= 作用类似,
  用于指向数据库中的信息.
+ =re-frame/db= 用于引用数据库
+ =re-frame/dispatch= 用于调用事件
+ =re-frame/subscribe= 用于注册信息

#+name: stage-1-namespace
#+begin_src clojure :tangle src/app/renderer/view.cljs
  (ns app.renderer.view
    (:require [reagent.core  :as reagent  :refer [atom cursor]]
              [re-frame.core :as re-frame :refer [dispatch subscribe]]))
#+end_src

*** Main
#+name: stage-1-main
#+begin_src clojure :noweb yes :tangle src/app/renderer/view.cljs
  ;;; Load svg helper
  <<stage-1-svg-helper>>

  ;;; Function to draw board
  <<stage-1-draw-board>>

  (defn main "Main View." []
    [draw-board])
#+end_src

一些用于绘制 svg 的一些小技巧:
+ 使用 =<g>...</g>= 即 =[:g ...]= 的形式来将 svg 中的元素组合在一起.
+ 与其使用 =x=, =y=, =(* width scale)= 等来设置位置和大小,
  不如使用 =transform= 即 =[:g {:transform "translate(...)"}]= 这样的形式. 

  #+name: stage-1-svg-helper
  #+begin_src clojure :tangle no
    (defn transform [& {:keys [x y s]}]
      {:transform (str (if (and x y) (str "translate(" x " " y ") ") "")
                       (if s         (str "scale(" s ")")            ""))})
  #+end_src

  (于是在使用的时候, 通过 =[:g (transform ...) ...]= 这样的形式就可以快速调用属性了)
  
*** Draw Board
想要绘制一个编辑画板 (Art-board), 所需要知道的信息:

#+name: stage-1-draw-board-info
#+begin_src clojure :tangle no
  (defonce SELECTED-ID (atom nil))        ; 当前选中的节点 ID
  (defonce SELECTED-PORT (atom nil))      ; 当前选中的端口 [node-id port-id]
  (defonce SCALE (atom 30))               ; 当前画布的缩放大小
  (defonce INFO-PAN (atom nil))          ; 是否绘制消息面板

  (defonce NODES (atom {                  ; 绘制节点信息
                 :A {
                     :id    :A
                     :color :orange
                     :type  :Number
                     :pos-x 0
                     :pos-y 1
                     :param { :num 1 }
                     :in    {}
                     :out   { :val [:C :a 0.5 0.25] }
                     }
                 :B {
                     :id    :B
                     :color :orange
                     :type  :Number
                     :pos-x 1
                     :pos-y 1
                     :param { :num 2 }
                     :in    {}
                     :out   { :val [:C :a 0.5 0.75] }
                     }
                 :C {
                     :id    :C
                     :color :black
                     :type  :Add
                     :pos-x 0
                     :pos-y 0
                     :param {}
                     :in    { :a [:A :val 0.25]
                              :b [:B :val 0.75] }
                     :out   { :val [nil nil 0.5 nil] }
                     }
                 }))
#+end_src

(注: 为了方便区分, 这里将外头定义的变量都使用大写来标识. )

+ 为什么要将 =NODES= 放在 =view.cljs= 中而不是数据库中?
  
  +因为不会+

  实际原因是因为感觉使用 =dispatch= 的速度不是很快,
  导致会有不跟手的感觉, 所以很难受.
  +虽然现在这样搞快了, 但是并没有快多少.+

  之后打算把绘制用的数据储存在 =view= 端,
  在 =db= 端虽然可以备份一份, 但是通过拷贝到 =view= 端的形式来进行加速绘制. 

绘制的整体框架如下:

#+name: stage-1-draw-board
#+begin_src clojure :noweb yes :tangle no
  <<stage-1-draw-board-info>>
  <<stage-1-draw-node>>
  <<stage-1-draw-art-board>>

  (defn draw-board []
    (fn []
        [:svg {:width 600
               :height 300
               :style {:border "2px solid black"}}
         [draw-artboard
          (for [[id node] @NODES]
            ^{:key (str "node" id)}
            [draw-node id node])]]))
#+end_src

其中的框架具体内容如下:
+ 绘制 Art-board (作为主要的入口)
  #+name: stage-1-draw-art-board
  #+begin_src clojure :tangle no
    (defn draw-artboard [& nodes]
      ;; local closure variable
      (let [width     (atom 600)      height    (atom 300)
            tr-x      (atom 0)        tr-y      (atom 0)
            scale     SCALE           dragging? (atom false)
            selected-id SELECTED-ID]
        ;; predefine functions
        (let [resize-artboard  (fn [mouse]
                                 (.stopPropagation mouse)
                                 (reset!
                                  scale
                                  (max 10 (min 100 (+ (* 0.05 mouse.deltaY) @scale)))))
              start-artboard   (fn [mouse]
                                 (.stopPropagation mouse)
                                 (condp = mouse.button
                                   0 (reset! dragging? true)
                                   2 (reset! INFO-PAN  [:add-node])
                                   '()))
              moving-artboard  (fn [mouse]
                                 (.stopPropagation mouse)
                                 (when @dragging?
                                   (reset! tr-x (+ @tr-x mouse.movementX))
                                   (reset! tr-y (+ @tr-y mouse.movementY))))
              stop-artboard    (fn [mouse]
                                 (reset! dragging? false))]
          (fn [node]
            [:g
             ;; Mask
             [:mask#art-board-background-mask
              [:rect {:width  @width
                      :height @height
                      :fill   :white}]]
             ;; Artboard
             [:g {:mask :art-board-background-mask}
              ;; background
              [:rect {:width  @width
                      :height @height
                      :fill   :white
                      :on-wheel       resize-artboard
                      :on-mouse-down  start-artboard
                      :on-mouse-move  moving-artboard
                      :on-mouse-leave stop-artboard
                      :on-mouse-up    stop-artboard}]
              ;; nodes
              [:g (transform :x @tr-x :y @tr-y :s @scale)
               nodes]]]))))
  #+end_src

  其中有一个两层的 =let= 函数, 分别用于声明所用的变量闭包以及内部使用的函数.
  (关于为什么提前定义内部使用的函数: 这是为了防止在之后重新绘制节点的时候,
  每次都需要重新执行并计算函数而浪费性能. ) 
+ 绘制节点

  #+name: stage-1-draw-node
  #+begin_src clojure :noweb yes :tangle no
    <<stage-1-draw-node-arc>>
    <<stage-1-draw-node-port>>
    <<stage-1-draw-node-body>>

    (defn draw-node [id node]
      (fn []
        (let [x (get-in @NODES [id :pos-x])
              y (get-in @NODES [id :pos-y])]
          [:g
           ;; draw node arc
           (doall
            (for [[port [to-node _ from-pos to-pos]] (node :out)
                  :when (not (nil? to-node))]
              ^{:key (str id "arc" port)}
              [draw-node-arc {
                              :x1  (+ 1 x)
                              :y1  (+ from-pos y)
                              :x2  (get-in @NODES [to-node :pos-x])
                              :y2  (+ to-pos (get-in @NODES [to-node :pos-y]))}]))

           ;; draw body
           ^{:key (str id "body")} [draw-node-body id {:x x :y y}]

           ;; draw in port
           (for [[port [_ _ dy]] (node :in)]
              ^{:key (str id "in" port)} [draw-node-port {:id id
                                                          :port port
                                                          :x x
                                                          :y (+ y dy)}])
           ;; draw out port
           (for [[port [_ _ dy _]] (node :out)]
              ^{:key (str id "out" port)} [draw-node-port {:id id
                                                           :port port
                                                           :x (+ x 1)
                                                           :y (+ y dy)}])])))
  #+end_src
  + 绘制节点主体
  
    #+name: stage-1-draw-node-body
    #+begin_src clojure :tangle no
      (defn draw-node-body [id {:keys [x y]}]
        (let [start-move (fn [node mouse]
                           (reset! SELECTED-ID node))
              move-node  (fn [id mouse]
                           (when (= id @SELECTED-ID)
                             (reset!
                              NODES
                              (-> @NODES
                                  (update-in [id :pos-x]
                                             #(+ % (/ mouse.movementX @SCALE)))
                                  (update-in [id :pos-y]
                                             #(+ % (/ mouse.movementY @SCALE)))))))
              end-move   (fn []
                           (reset! SELECTED-ID nil))]
          (fn [id {:keys [x y]}]
            [:g (transform :x x :y y)
             [:rect {:width 1
                    :height 1
                    :fill @(cursor NODES [id :color])
                    :on-mouse-down  #(start-move id %)
                    :on-mouse-move  #(move-node id %)
                    :on-mouse-leave end-move
                    :on-mouse-up    end-move}]])))
    #+end_src
  + 绘制节点的边
  
    #+name: stage-1-draw-node-arc
    #+begin_src clojure :tangle no

      (defn draw-node-arc [{:keys [x1 y1 x2 y2]}]
        (fn [{:keys [x1 y1 x2 y2]}]
          (let [weight (min 5 (abs (* -0.1 (- y2 y1) (- x2 x1))))]
            [:svg/path {:d (str "M" x1 " " y1 " "
                            "C" (+ x1 weight) " " y1 ", "
                            (- x2 weight) " " y2 ", "
                            x2 " " y2)
                        :stroke :black
                        :stroke-width 0.1
                        :fill :none}])))
    #+end_src
  + 绘制节点的接口

    #+name: stage-1-draw-node-port
    #+begin_src clojure
      (defn draw-node-port [{:keys [id port x y]}]
        (let [select-port (fn [node-id port-id mouse]
                            (println :clicked @SELECTED-PORT)
                            (condp = mouse.button
                              0 (reset! SELECTED-PORT [node-id port-id])
                              '()))]
         (fn [{:keys [x y]}]
           [:circle {:cx x
                     :cy y
                     :r  0.1
                     :stroke :black
                     :stroke-width 0.05
                     :fill (let [[node-id port-id] @SELECTED-PORT]
                             (if (and (= node-id id)
                                      (= port-id port))
                               :orange
                               :white))
                     :on-mouse-down #(select-port id port %)}])))
    #+end_src

** events
在 =app.renderer.events= Namespace 中定义程序的主要的控制事件:

#+begin_src clojure :tangle src/app/renderer/events.cljs
  (ns app.renderer.events
    (:require [re-frame.core   :as re-frame :refer [reg-event-db reg-event-fx]]
              [app.renderer.db :as database :refer [default-db]]))
#+end_src

+ 初始化数据库

  #+begin_src clojure :tangle src/app/renderer/events.cljs
    (reg-event-db
     :initialize-db
     (fn [_ _] default-db))
  #+end_src

* COMMENT LocalWords
#  LocalWords: LocalWords magit svg cljs noweb
