#+title: Make Myself A Node Editor
#+author: 凉凉
* About
记录一下使用 ClojureScript 和 Reagent 来制作一个节点编辑器的过程.
方便之后去进行回看代码. 同时也尝试一下在更加复杂的工作环境下,
使用 org-mode 进行文学编程的可能性.

未来可能会更新到博客里面. (在写了)

(该项目本来应该用在 iGEM 里面的. )

** 可能会使用到的技术栈
+ git (我将尝试使用 [[https://magit.vc][magit]] 来进行辅助)
+ [[https://clojurescript.org][ClojureScript]] (实际上是将 [[https://clojure.org][Clojure]] 编译成 JavaScript 的实现)
+ [[https://reagent-project.github.io][Reagent]], 是 [[https://react.dev][React]] 的 ClojureScript 的绑定
+ [[https://github.com/day8/re-frame][Re-frame]], 一个类似于简化 Reagent 设计的一个框架.
  +结果最终还是不用了+
+ [[https://github.com/thheller/shadow-cljs][shadow-cljs]], 用于配置和与 npm 进行沟通
+ [[https://www.electronjs.org][Electron]], 一个类似于将网页作为本地软件的一个框架
  (如果说难听点, 就是 chromium 内核. )

** 目标和计划
+梦里啥都有...+

+ 做一个能够自定义节点类和边类, 自定义节点图标的一个节点编辑器 (Electron)
+ 节点可以执行任意代码作为后端实现, 不是局限于 Clojure (Electron)

* Stage 0
一个 "你就说它能不能动吧" 的开头.

(可以到本项目的 [[https://github.com/li-yiyang/write-myself-a-node-editor/tree/initialized-the-project][initialized-the-project]] 分支查看)

实际上其中大部分都是些辛苦的体力活, 没什么高级的地方.
一些约定:

#+begin_src shell
  > tree . -I "node_modules"
  .
  |-- LICENSE                     ; MIT 协议
  |-- README.org                  ; 本文档
  |-- package-lock.json
  |-- package.json                ; npm 配置
  |-- rescources                  ; 导出的目录
  |   `-- public
  |       `-- index.html
  |-- shadow-cljs.edn             ; shadow-cljs 依赖
  `-- src
      `-- app
          |-- main                ; electron 部分
          |   `-- core.cljs
          `-- renderer            ; 页面部分 (主体)
              |-- core.cljs
              |-- db.cljs
              |-- events.cljs
              |-- subs.cljs
              `-- view.cljs
#+end_src

* Stage 1 - Models and Views
** Overview
*** core
在 =app.renderer.core= 的 Namespace 下,
描述 =start!= 的逻辑:

#+begin_src clojure :tangle src/app/renderer/core.cljs
  (ns app.renderer.core
    (:require [reagent.dom         :as reagentdom  :refer [render]]
              [app.renderer.view   :as view        :refer [main]]
              [devtools.core       :as devtools]
              ))

  (defn ^:dev/after-load start! "Start Renderer" []
    (enable-console-print!)               ; for dev usage
    (devtools/install!)
    (render [main] (.getElementById js/document "app-container")))
#+end_src

其中 =start!= 的逻辑:
+ 为了调试方便, 打开了在游览器终端中输出信息的功能;
+ 初始化数据库;
+ 将 =view/main= 渲染进 id 为 =app-container= 的 HTML 元素中. 

*** view
在 =app.renderer.view= 的 Namespace 下,
调用 =reagent=, =re-frame= 的库, 引用:
+ =reagent/atom= 用于使用 =atom= 作为容器存放可记录的数据,
  在被更改的时候会使得 Reagent 刷新页面.
+ =reagent/cursor= 和 =atom= 作用类似,
  用于指向数据库中的信息.
+ =re-frame/db= 用于引用数据库
+ =re-frame/dispatch= 用于调用事件
+ =re-frame/subscribe= 用于注册信息

#+name: stage-1-namespace
#+begin_src clojure :tangle src/app/renderer/view.cljs
  (ns app.renderer.view
    (:require [reagent.core  :as reagent  :refer [atom cursor]]
              [re-frame.core :as re-frame :refer [dispatch subscribe]]))
#+end_src

** Main
#+name: stage-1-main
#+begin_src clojure :noweb yes :tangle src/app/renderer/view.cljs
  ;;; Load svg helper
  <<stage-1-svg-helper>>

  ;;; Function to draw board
  <<stage-1-draw-board>>

  ;;; Info pan
  <<stage-1-draw-info-pan>>

  (defonce WIDTH (atom js/window.innerWidth))
  (defonce HEIGHT (atom js/window.innerHeight))

  (defn main "Main View." []
    (fn []
       [:svg {:width  @WIDTH
              :height @HEIGHT
              :style {:background "#CCC"}}
        [draw-board]
        [draw-info-pan]]))
#+end_src

*** svg-helper
一些用于绘制 svg 的一些小技巧:
+ 使用 =<g>...</g>= 即 =[:g ...]= 的形式来将 svg 中的元素组合在一起.
+ 与其使用 =x=, =y=, =(* width scale)= 等来设置位置和大小,
  不如使用 =transform= 即 =[:g {:transform "translate(...)"}]= 这样的形式. 

  #+name: stage-1-svg-helper
  #+begin_src clojure :tangle no
    (defn transform [& {:keys [x y s]}]
      {:transform (str (if (and x y) (str "translate(" x " " y ") ") "")
                       (if s         (str "scale(" s ")")            ""))})
  #+end_src

  (于是在使用的时候, 通过 =[:g (transform ...) ...]= 这样的形式就可以快速调用属性了)
  
** Draw Board
*** Overview
绘制的整体框架如下:

#+name: stage-1-draw-board
#+begin_src clojure :noweb yes :tangle no
  ;;; Info and Data
  <<stage-1-draw-board-info>>

  ;;; Nodes
  <<stage-1-draw-node>>

  ;;; Art-board
  <<stage-1-draw-art-board>>

  (defn draw-board []
    (let [nodes DRAWED-NODES]
      (fn []
        [draw-artboard
         ^{:key :draw-arcs} [draw-arcs]
         ^{:key :draw-nodes} [draw-nodes]])))
#+end_src

*** Data
**** info-data
想要绘制一个编辑画板 (Art-board), 所需要知道的信息:

#+name: stage-1-draw-board-info
#+begin_src clojure :noweb yes :tangle no
  (defonce SELECTED-ID (atom nil))        ; 当前选中的节点 ID
  (defonce SELECTED-PORT (atom nil))      ; 当前选中的端口 [node-id port-id]
  (defonce SCALE (atom 30))               ; 当前画布的缩放大小
  (defonce INFO-PAN (atom nil))           ; 是否绘制消息面板
  (defonce TR-X (atom 0))                 ; 画板 X 方向的位移量
  (defonce TR-Y (atom 0))                 ; 画板 Y 方向的位移量

  (defonce CLASS (atom {                  ; 节点类的信息
                        :Number {
                                 :class :Number
                                 :param {:num 0}
                                 :color :orange
                                 :in-pos  {}
                                 :out-pos {:val [1 0.5]}
                                 :in    []
                                 :out   {:val 0}
                                 :func  (fn [{:keys [num]}] { :val num })
                                 }
                        :Add    {
                                 :class   :Add
                                 :param   {}
                                 :color   :black
                                 :in-pos  {:a [0 0.25] :b [0 0.75]}
                                 :out-pos {:val [1 0.5]}
                                 :in      {:a 0 :b 0}
                                 :out     {:val 0}
                                 :func    (fn [{:keys [a b]}] { :val (+ a b) })
                                 }
                        }))

  (defonce NODES (atom {}))               ; 储存节点信息
  (defonce ARCS  (atom #{}))              ; 储存边信息

  (defonce DRAWED-NODES (atom '()))       ; 绘制的节点结果
  (defonce DRAWED-ARCS  (atom '()))       ; 绘制的边结果

  <<stage-1-draw-info-data>>
#+end_src

(注: 为了方便区分, 这里将外头定义的变量都使用大写来标识. )

**** data-manipulate
以及数据的处理和操作

#+name: stage-1-draw-info-data
#+begin_src clojure :noweb yes :tangle no
  ;;; Add/Delete Node
  <<stage-1-node-add-delete>>

  ;;; Add/Delete Arcs
  <<stage-1-arc-add-delete>>
#+end_src

+ 节点增加和删除
  
  #+name: stage-1-node-add-delete
  #+begin_src clojure :tangle no
    (defn del-node [id]
      (swap! NODES dissoc id))

    (defn add-node [& {:keys [name type x y]}]
      (let [id (random-uuid)
            {:keys [param in out func
                    in-pos out-pos color]} (@CLASS type)]
        (swap! NODES assoc id {:class type
                               :name  name
                               :param param
                               :pos-x x
                               :pos-y y
                               :in    in
                               :out   out
                               :func  func
                               :in-pos  in-pos
                               :out-pos out-pos
                               :color   color})))

    (defn random-name []
      "name")
  #+end_src
+ 节点边增加, 删除, 以及查找

  #+name: stage-1-arc-add-delete
  #+begin_src clojure :tangle no
    (defn add-arc [from-node from-port to-node to-port]
      (cond
        (and (get-in @NODES [from-node :out-pos from-port])
             (get-in @NODES [to-node   :in-pos  to-port]))
        (swap! ARCS conj [from-node from-port to-node to-port])
    
        (and (get-in @NODES [from-node :in-pos  from-port])
             (get-in @NODES [to-node   :out-pos to-port]))
        (swap! ARCS conj [to-node to-port from-node from-port])))

    (defn delete-arc [from-node from-port to-node to-port]
      (swap! ARCS disj [from-node from-port to-node to-port]))

    (defn finde-arc [{:keys [from-node from-port to-node to-port]}]
      (some @ARCS (fn [[f-n f-p t-n t-p]]
                    (and (or (nil? from-node) (= from-node f-n))
                         (or (nil? from-port) (= from-port f-p))
                         (or (nil? to-node)   (= to-node   t-n))
                         (or (nil? to-port)   (= to-port   t-p))))))
  #+end_src
*** View
其中的框架具体内容如下:

**** art-board
绘制 Art-board (作为主要的入口)
#+name: stage-1-draw-art-board
#+begin_src clojure :tangle no
  (defn draw-artboard [& nodes]
    ;; local closure variable
    (let [width     (atom 600)      height    (atom 300)
          dragging? (atom false)]
      ;; predefine functions
      (let [resize-artboard  (fn [mouse]
                               (.stopPropagation mouse)
                               (reset!
                                SCALE
                                (max 10 (min 100 (+ (* 0.05 mouse.deltaY) @SCALE)))))
            start-artboard   (fn [mouse]
                               (.stopPropagation mouse)
                               (condp = mouse.button
                                 0 (do
                                     (reset! INFO-PAN nil)
                                     (reset! dragging? true))
                                 2 (do
                                     (reset! INFO-PAN  {:x mouse.clientX
                                                        :y mouse.clientY
                                                        :type :add}))
                                 nil))
            moving-artboard  (fn [mouse]
                               (.stopPropagation mouse)
                               (when @dragging?
                                 (reset! TR-X (+ @TR-X mouse.movementX))
                                 (reset! TR-Y (+ @TR-Y mouse.movementY))))
            stop-artboard    (fn [mouse]
                               (reset! dragging? false))]
        (fn [node]
          [:g
           ;; Mask
           [:mask#art-board-background-mask
            [:rect {:width  @width
                    :height @height
                    :fill   :white
                    :stroke :black
                    :stroke-width 3}]]
           ;; Artboard
           [:g {:transform "translate(10 10)"}
            ;; background
            [:rect {:width  @width
                    :height @height
                    :fill   :white
                    :stroke :black
                    :stroke-width 3
                    :on-wheel       resize-artboard
                    :on-mouse-down  start-artboard
                    :on-mouse-move  moving-artboard
                    :on-mouse-leave stop-artboard
                    :on-mouse-up    stop-artboard}]
            ;; nodes
            [:g {:mask "url(#art-board-background-mask)"}
             [:g (transform :x @TR-X :y @TR-Y :s @SCALE)
              nodes]]]]))))
#+end_src

其中有一个两层的let函数分别用于声明所用的变量闭包以及内部使用的函数.
 关于为什么提前定义内部使用的函数这是为了防止在之后重新绘制节点的时候,
每次都需要重新执行并计算函数而浪费性能. ) 

**** draw-node-arc
绘制节点的边  

#+name: stage-1-draw-node-arc  
#+begin_src clojure :tangle no
  (defn draw-node-arc [{:keys [x1 y1 x2 y2]}]
    (fn [{:keys [x1 y1 x2 y2]}]
      (let [weight (min 5 (* 0.1 (abs (- y2 y1)) (max 2 (abs (- x2 x1)))))]
        [:path {:d (str "M" x1 " " y1 " "
                        "C" (+ x1 weight) " " y1 ", "
                        (- x2 weight) " " y2 ", "
                        x2 " " y2)
                :stroke :black
                :stroke-width 0.1
                :fill :none}])))

  (defn draw-arcs []
    (fn []
      [:g
       (doall
        (for [[from-node from-port to-node to-port] @ARCS]
          (let [x1 @(cursor NODES [from-node :pos-x])
                y1 @(cursor NODES [from-node :pos-y])
                x2 @(cursor NODES [to-node :pos-x])
                y2 @(cursor NODES [to-node :pos-y])
                [dx1 dy1] @(cursor NODES [from-node :out-pos from-port])
                [dx2 dy2] @(cursor NODES [to-node   :in-pos  to-port])]
            ^{:key (str "arc-" from-node from-port to-node to-port)}
            [draw-node-arc {:x1 (+ x1 dx1) :y1 (+ y1 dy1)
                            :x2 (+ x2 dx2) :y2 (+ y2 dy2)}])))]))
#+end_src

**** draw-node
绘制节点
+ 整体
  #+name: stage-1-draw-node
  #+begin_src clojure :noweb yes :tangle no
    ;;; Draw nodes
    <<stage-1-draw-node-arc>>
    <<stage-1-draw-node-port>>
    <<stage-1-draw-node-body>>

    (defn draw-node [id node]
      (fn []
        (let [x (get-in @NODES [id :pos-x])
              y (get-in @NODES [id :pos-y])]
          [:g
           ;; draw body
           ^{:key (str id "body")} [draw-node-body id {:x x :y y}]

           ;; draw in port
           (for [[port [dx dy]] (node :in-pos)]
             ^{:key (str id "in" port)} [draw-node-port {:id   id
                                                         :port port
                                                         :x    (+ x dx)
                                                         :y    (+ y dy)}])

           ;; draw out port
           (for [[port [dx dy]] (node :out-pos)]
             ^{:key (str id "out" port)} [draw-node-port {:id   id
                                                          :port port
                                                          :x    (+ x dx)
                                                          :y    (+ y dy)}])])))

    (defn draw-nodes []
      (fn []
        [:g
         (for [[id node] @NODES]
          ^{:key (str "node" id)} [draw-node id node])]))
  #+end_src
+ 绘制节点主体
  
  #+name: stage-1-draw-node-body
  #+begin_src clojure :tangle no
    (defn draw-node-body [id {:keys [x y]}]
      (let [start-move (fn [node mouse]
                         (condp = mouse.button
                           0 (do
                               (reset! INFO-PAN nil)
                               (reset! SELECTED-ID node))
                           2 (do
                               (reset! INFO-PAN {:x mouse.clientX
                                                 :y mouse.clientY
                                                 :type :node
                                                 :info node}))
                           '()))
            move-node  (fn [id mouse]
                         (when (= id @SELECTED-ID)
                           (reset!
                            NODES
                            (-> @NODES
                                (update-in [id :pos-x]
                                           #(+ % (/ mouse.movementX @SCALE)))
                                (update-in [id :pos-y]
                                           #(+ % (/ mouse.movementY @SCALE)))))))
            end-move   (fn []
                         (reset! SELECTED-ID nil))]
        (fn [id {:keys [x y]}]
          [:g (transform :x x :y y)
           [:rect {:width 1
                  :height 1
                  :fill @(cursor NODES [id :color])
                  :on-mouse-down  #(start-move id %)
                  :on-mouse-move  #(move-node id %)
                  :on-mouse-leave end-move
                  :on-mouse-up    end-move}]])))
  #+end_src
+ 绘制节点的接口

  #+name: stage-1-draw-node-port
  #+begin_src clojure
    (defn draw-node-port [{:keys [id port x y]}]
      (let [select-port (fn [node-id port-id mouse]
                          (condp = mouse.button
                            0 (if (nil? @SELECTED-PORT)
                                (reset! SELECTED-PORT [node-id port-id])
                                (let [[id2 port2] @SELECTED-PORT]
                                  (reset! SELECTED-PORT nil)
                                  (add-arc id2 port2 node-id port-id)))
                            '()))]

       (fn [{:keys [x y]}]
         [:circle {:cx x
                   :cy y
                   :r  0.1
                   :stroke :black
                   :stroke-width 0.05
                   :fill (let [[node-id port-id] @SELECTED-PORT]
                           (if (and (= node-id id)
                                    (= port-id port))
                             :orange
                             :white))
                   :on-mouse-down #(select-port id port %)}])))
  #+end_src
** Info-pan
绘制 Info-pan: 用于展示节点的信息, 添加或者删除节点等进行交互的工作. 

#+name: stage-1-draw-info-pan
#+begin_src clojure :noweb yes :tangle no
  <<stage-1-draw-add-pan>>
  <<stage-1-draw-node-pan>>

  (defn draw-info-pan []
    (let [width  150
          height 200
          rect   [:rect {:width  width
                     :height height
                     :fill   :white
                     :fill-opacity 0.5
                     :stroke :black
                     :stroke-width 2}]]
      (fn []
        (when-not (nil? @INFO-PAN)
          (let [{:keys [type x y info]} @INFO-PAN]
            [:g (transform :x x :y y)
             [:mask#info-pan-mask rect]
             rect
             [:foreignObject {:mask "url(info-pan-mask)"
                              :width width
                              :height height}
              [:div {:style {:overflow-y :scroll
                             :width "100%"
                             :height "100%"
                             :margin 0
                             :padding 0}}
               (condp = type
                  :add  [draw-add-pan info]
                  :node [draw-node-pan info]
                  '())]]])))))
#+end_src

+ 绘制添加节点的表单
    
  #+name: stage-1-draw-add-pan
  #+begin_src clojure :tangle no
    (defn draw-add-pan [info]
      (let [search (atom "")]
        (let [update-value #(reset! search (-> % .-target .-value))
              make-new-node (fn [type mouse]
                              (let [x (/ (- mouse.clientX @TR-X) @SCALE)
                                    y (/ (- mouse.clientY @TR-Y) @SCALE)]
                                (reset! INFO-PAN nil)
                                (add-node {:name (random-name)
                                           :type type
                                           :x x
                                           :y y})))]
         (fn []
           [:div
            [:div.info-title {:style {:background "#CCC"
                                      :padding "3px"}}
             "Add Node"]
            [:div.input-field {:style {:padding "3px"}}
             [:input {:style {:width "60%"}
                     :value @search
                     :placeholder "Class"
                     :on-change update-value}]]
            (for [[type _] @CLASS]
              ^{:key (str "i-p-s-" type)}
              [:div.type-select {:style {:padding "3px"}
                                 :on-click #(make-new-node type %)}
               (str type)])]))))
  #+end_src
+ 绘制节点信息表单
    
  #+name: stage-1-draw-node-pan
  #+begin_src clojure :tangle no
    (defn draw-node-pan [info]
      (let [params (atom {})
            name-f (atom "")
            editname? (atom false)]
        (let [update-param (fn [arg input]
                             #(reset!
                               params
                               (assoc @params arg (-> input .-target .-value))))
              update-name (fn [input]
                            #(reset! name-f (-> input .-target .-value)))]
         (fn []
           (let [{:keys [param color name]} @(cursor NODES [info])]
             (reset! name-f name)
             (reset! editname? false)
             (reset! params param)
             [:div
              [:div.info-title {:style {:background color
                                        :padding "3px"}}
               (if @editname?
                 [:input.info-input {:value @name-f
                                     :style {:width "30%"
                                             :padding "2px"
                                             :margin "0"
                                             :margin-right "3px"}
                                     :on-change update-name}]
                 [:span {:on-click #(println :clicked)}
                  @name-f])]
              (for [[arg val] param]
                ^{:key (str "info-p-" arg)}
                [:div.info-item {:style {:margin-top "3px"
                                         :margin-left "2px"
                                         :margin-right "2px"}}
                 [:span.info-label  {:style {:width "30%"
                                             :padding "2px"
                                             :margin "0"
                                             :margin-right "3px"}}
                  arg]
                 [:input.info-input {
                                     :style {:width "50%"
                                             :padding "2px"
                                             :margin "0"}
                                     :on-change update-param}]])
              [:button.info-button {:width "80%"}
               "delete node"]])))))
  #+end_src
    
* COMMENT LocalWords
#  LocalWords: LocalWords magit svg cljs noweb
