#+title: Make Myself A Node Editor
#+author: 凉凉
* About
记录一下使用 ClojureScript 和 Reagent 来制作一个节点编辑器的过程.
方便之后去进行回看代码. 同时也尝试一下在更加复杂的工作环境下,
使用 org-mode 进行文学编程的可能性.

未来可能会更新到博客里面. (在写了)

(该项目本来应该用在 iGEM 里面的. )

** 可能会使用到的技术栈
+ git (我将尝试使用 [[https://magit.vc][magit]] 来进行辅助)
+ [[https://clojurescript.org][ClojureScript]] (实际上是将 [[https://clojure.org][Clojure]] 编译成 JavaScript 的实现)
+ [[https://reagent-project.github.io][Reagent]], 是 [[https://react.dev][React]] 的 ClojureScript 的绑定
+ [[https://github.com/day8/re-frame][Re-frame]], 一个类似于简化 Reagent 设计的一个框架.
  +结果最终还是不用了+
+ [[https://github.com/thheller/shadow-cljs][shadow-cljs]], 用于配置和与 npm 进行沟通
+ [[https://www.electronjs.org][Electron]], 一个类似于将网页作为本地软件的一个框架
  (如果说难听点, 就是 chromium 内核. )

** 目标和计划
+梦里啥都有...+

+ 做一个能够自定义节点类和边类, 自定义节点图标的一个节点编辑器 (Electron)
+ 节点可以执行任意代码作为后端实现, 不是局限于 Clojure (Electron)

* Stage 0
一个 "你就说它能不能动吧" 的开头.

(可以到本项目的 [[https://github.com/li-yiyang/write-myself-a-node-editor/tree/initialized-the-project][initialized-the-project]] 分支查看)

实际上其中大部分都是些辛苦的体力活, 没什么高级的地方.
一些约定:

#+begin_src shell
  > tree . -I "node_modules"
  .
  |-- LICENSE                     ; MIT 协议
  |-- README.org                  ; 本文档
  |-- package-lock.json
  |-- package.json                ; npm 配置
  |-- rescources                  ; 导出的目录
  |   `-- public
  |       `-- index.html
  |-- shadow-cljs.edn             ; shadow-cljs 依赖
  `-- src
      `-- app
          |-- main                ; electron 部分
          |   `-- core.cljs
          `-- renderer            ; 页面部分 (主体)
              |-- core.cljs
              |-- db.cljs
              |-- events.cljs
              |-- subs.cljs
              `-- view.cljs
#+end_src

* Stage 1 - Models and Views
** Overview
*** demo
#+caption: A very simple Demo
[[img/demo-4-23.gif]]

目前实现的功能:
+ [x] 绘制节点和边
+ [x] 删除节点和边
+ [x] 修改节点的值

使用方法:
+ 画板内可以拖动 (左键点击和拖放) 和缩放 (滚轮上下移动)
+ 弹出菜单:
  + 在空白处右键单击添加节点
  + 在节点上 (左键) 单击 (不拖动) 或者右键单击修改节点
  + 在边上 (左键) 单击修改边
*** core
在 =app.renderer.core= 的 Namespace 下,
描述 =start!= 的逻辑:

#+begin_src clojure :tangle src/app/renderer/core.cljs
  (ns app.renderer.core
    (:require [reagent.dom         :as reagentdom  :refer [render]]
              [app.renderer.view   :as view        :refer [main]]
              [devtools.core       :as devtools]))

  (defn ^:dev/after-load start! "Start Renderer" []
    (enable-console-print!)               ; for dev usage
    (devtools/install!)
    (render [main] (.getElementById js/document "app-container")))
#+end_src

其中 =start!= 的逻辑:
+ 为了调试方便, 打开了在游览器终端中输出信息的功能;
+ 初始化数据库;
+ 将 =view/main= 渲染进 id 为 =app-container= 的 HTML 元素中. 

*** view
在 =app.renderer.view= 的 Namespace 下,
调用 =reagent= 的库, 引用:
+ =reagent/atom= 用于使用 =atom= 作为容器存放可记录的数据,
  在被更改的时候会使得 Reagent 刷新页面.
+ =reagent/cursor= 和 =atom= 作用类似,
  用于指向数据库中的信息.

#+name: stage-1-namespace
#+begin_src clojure :noweb yes :tangle src/app/renderer/view.cljs
  (ns app.renderer.view
    (:require [reagent.core        :as reagent     :refer [atom cursor]]
              [app.fun.randomname                  :refer [random-name]]
              [app.parser.core     :as parser      :refer [parse]]))
#+end_src

** Main
#+name: stage-1-main
#+begin_src clojure :noweb yes :tangle src/app/renderer/view.cljs
  ;;; JS Window Info
  (defonce WIDTH (atom js/window.innerWidth))
  (defonce HEIGHT (atom js/window.innerHeight))
  (defonce SIDE-BAR-WIDTH (atom 200))

  ;;; Load svg helper
  <<stage-1-svg-helper>>

  ;;; Function to draw board
  <<stage-1-draw-board>>

  ;;; Info pan
  <<stage-1-draw-info-pan>>

  ;;; Sidebar
  <<stage-1-draw-side-bar>>

  (defn main "Main View." []
    (let [handler (clj->js (fn []
                             (reset! WIDTH  (.-innerWidth js/window))
                             (reset! HEIGHT (.-innerHeight js/window))))]
      (let [_ (.addEventListener js/window "resize" handler)]
        (fn []
          [:svg {:width  @WIDTH
                 :height @HEIGHT
                 :style {:background "#CCC"}}
           [draw-board]
           [draw-info-pan]
           [draw-side-bar]]))))
#+end_src

*** svg-helper
一些用于绘制 svg 的一些小技巧:
+ 使用 =<g>...</g>= 即 =[:g ...]= 的形式来将 svg 中的元素组合在一起.
+ 与其使用 =x=, =y=, =(* width scale)= 等来设置位置和大小,
  不如使用 =transform= 即 =[:g {:transform "translate(...)"}]= 这样的形式. 

  #+name: stage-1-svg-helper
  #+begin_src clojure :tangle no
    (defn transform [& {:keys [x y s]}]
      {:transform (str (if (and x y) (str "translate(" x " " y ") ") "")
                       (if s         (str "scale(" s ")")            ""))})
  #+end_src

  (于是在使用的时候, 通过 =[:g (transform ...) ...]= 这样的形式就可以快速调用属性了)
  
*** basic CSS
一些最简单的 CSS 设置, (目前主要是写在代码里面的样式, 需要改进...)

#+begin_src css :tangle rescources/public/css/main.css
  body {
    padding: 0;
    margin: 0;
    overflow: hidden;
    font-family: "Helvetica Neue", "Arial", sans-serif;
  }
#+end_src

** Data
*** info-data
想要绘制一个编辑画板 (Art-board), 所需要知道的信息:

注: [2023-05-24] 需要重构 =CLASS= 和 =NODES= 的代码,
以及需要重新写 =eval-node= 的部分的代码,
使得在计算过程中无用的开销减少. 

#+name: stage-1-draw-board-info
#+begin_src clojure :noweb yes :tangle no
  (defonce SELECTED-ID (atom nil))        ; 当前选中的节点 ID
  (defonce SELECTED-PORT (atom nil))      ; 当前选中的端口 [node-id port-id]
  (defonce SCALE (atom 30))               ; 当前画布的缩放大小
  (defonce INFO-PAN (atom nil))           ; 是否绘制消息面板
  (defonce TR-X (atom 0))                 ; 画板 X 方向的位移量
  (defonce TR-Y (atom 0))                 ; 画板 Y 方向的位移量

  (defonce CLASS (atom {                  ; 节点类的信息
                        :Input {
                                 :class :Input
                                 :param {:exp ""}
                                 :color :orange
                                 :in-pos  {}
                                 :out-pos {:val [1 0.5]}
                                 :in    {}
                                 :out   {:val 0}
                                 :func  (fn [{:keys [exp]}]
                                          { :val exp })
                                 }
                        :Add    {
                                 :class   :Add
                                 :param   {}
                                 :color   :black
                                 :in-pos  {:a [0 0.25] :b [0 0.75]}
                                 :out-pos {:val [1 0.5]}
                                 :in      {:a 0 :b 0}
                                 :out     {:val 0}
                                 :func    (fn [{:keys [a b]}]
                                            (println 'Add (str "(" a ") + (" b ")"))
                                            { :val (parser/calculate
                                                    (str "(" a ") + (" b ")")) })
                                 }
                        :Sub    {
                                 :class   :Sub
                                 :param   {}
                                 :color   :grey
                                 :in-pos  {:a [0 0.25] :b [0 0.75]}
                                 :out-pos {:val [1 0.5]}
                                 :in      {:a 0 :b 0}
                                 :out     {:val 0}
                                 :func    (fn [{:keys [a b]}]
                                            {:val (parser/calculate
                                                   (str "(" a ") + (" b ")"))})
                                 }
                        :Out    {
                                 :class   :Out
                                 :param   {}
                                 :color   :black
                                 :in-pos  {:a [0 0.5]}
                                 :out-pos {}
                                 :in      {:a nil}
                                 :out     {}
                                 :func    (fn [{:keys [a]}]
                                            (println a)
                                            {})}
                        }))

  (defonce NODES (atom {}))               ; 储存节点信息
  (defonce ARCS  (atom #{}))              ; 储存边信息

  (defonce DRAWED-NODES (atom '()))       ; 绘制的节点结果
  (defonce DRAWED-ARCS  (atom '()))       ; 绘制的边结果

  <<stage-1-draw-info-data>>
#+end_src

(注: 为了方便区分, 这里将外头定义的变量都使用大写来标识. )

*** data-manipulate
以及数据的处理和操作

#+name: stage-1-draw-info-data
#+begin_src clojure :noweb yes :tangle no
  ;;; Add/Delete Arcs
  <<stage-1-arc-add-delete>>

  ;;; Add/Delete Node
  <<stage-1-node-add-delete>>

  ;;; Node Evaluate
  <<stage-2-eval-node>>
#+end_src

+ 节点边增加, 删除, 以及查找

  目前对于边的存储的方式, 使用一个长度为 4 的 vector 来进行储存.
  每个边的节点储存形式如下 =[from-node from-port to-node to-port]=.
  =ARCS= 为一个存放 set 的 atom, 使得边的储存是唯一的,
  即两个节点之间不会有平行线. 

  #+name: stage-1-arc-add-delete
  #+begin_src clojure :noweb yes :tangle no
    ;;; Delete arc by [from-node from-port to-node to-port]
    <<stage-1-delete-arc>>

    ;;; Find arc(s) by {:from-node ... :from-port ... ...}
    <<stage-1-find-arc>>

    ;;; Add arc by [from-node from-port to-node to-port]
    <<stage-1-add-arc>>
  #+end_src
  + 边的删除

    #+name: stage-1-delete-arc
    #+begin_src clojure :tangle no
      (defn delete-arc [from-node from-port to-node to-port]
        (swap! ARCS disj [from-node from-port to-node to-port]))
    #+end_src

    使用 [[https://cljs.github.io/api/cljs.core/disj][=disj=]] 方法从 =ARCS= 中删除边.
  + 边的查找

    #+name: stage-1-find-arc
    #+begin_src clojure :tangle no
      (defn find-arc [{:keys [from-node from-port to-node to-port]}]
        (filter (fn [[f-n f-p t-n t-p]]
                  (and (or (nil? from-node) (= from-node f-n))
                       (or (nil? from-port) (= from-port f-p))
                       (or (nil? to-node)   (= to-node   t-n))
                       (or (nil? to-port)   (= to-port   t-p))))
                @ARCS ))
    #+end_src

    使用 [[https://cljs.github.io/api/cljs.core/filter][=filter=]] 方法从 =ARCS= 中筛选符合条件的边, 通过四个关键词进行限定匹配. 
  + 边的增加

    #+name: stage-1-add-arc
    #+begin_src clojure :tangle no
      (defn add-arc [from-node from-port to-node to-port]
        (cond
          (and (get-in @NODES [from-node :out-pos from-port])
               (get-in @NODES [to-node   :in-pos  to-port]))
          (do
            (doall (for [[f-n f-p t-n t-p] (find-arc {:to-node to-node
                                                      :to-port to-port})]
                     (delete-arc f-n f-p t-n t-p)))
            (swap! ARCS conj [from-node from-port to-node to-port]))

          (and (get-in @NODES [from-node :in-pos  from-port])
               (get-in @NODES [to-node   :out-pos to-port]))
          (do
            (doall (for [[f-n f-p t-n t-p] (find-arc {:to-node from-node
                                                      :to-port from-port})]
                     (delete-arc f-n f-p t-n t-p)))
            (swap! ARCS conj [to-node to-port from-node from-port]))))
    #+end_src

    在添加节点前进行判断, 检测出入节点 (因为边的逻辑是 =from -> to= 的有向边);
    而为了使得不会存在一个入点存在多条边同时进入, 在添加前先删除所有的其他入边.

    于是目前一个端口可以对应多个出边, 但是只能有一个入边. 
+ 节点增加和删除
  
  #+name: stage-1-node-add-delete
  #+begin_src clojure :noweb yes :tangle no
    ;;; Delete Node
    <<stage-1-del-node>>

    ;;; Add Node
    <<stage-1-add-node>>
  #+end_src

  + 节点的删除

    #+name: stage-1-del-node
    #+begin_src clojure :tangle no
      (defn del-node [id]
        ;; delete in arcs
        (doseq [[from-node from-port to-node to-port] (find-arc {:from-node id})]
          (delete-arc from-node from-port to-node to-port))

        ;; delete out arcs
        (doseq [[from-node from-port to-node to-port] (find-arc {:to-node id})]
          (delete-arc from-node from-port to-node to-port))

        ;; delete the node
        (swap! NODES dissoc id))
    #+end_src
    + 首先删除所有的出/入边
    + 然后删除对应的节点
  + 节点的增加

    #+name: stage-1-add-node
    #+begin_src clojure
      (defn add-node [& {:keys [name type x y]}]
        (let [id (random-uuid)
              {:keys [param in out func
                      in-pos out-pos color]} (@CLASS type)]
          (swap! NODES assoc id {:class type
                                 :name  name
                                 :param param
                                 :pos-x x
                                 :pos-y y
                                 :in    in
                                 :out   out
                                 :in-pos  in-pos
                                 :out-pos out-pos
                                 :color   color})))
    #+end_src
  + =random-name= 之后会加入自动生成一个随机名字的函数
    +(属于是传统艺能了, 可以看看我计科导作业 [[https://github.com/li-yiyang/CARDs][CARDs]] 的 motto 的生成)+

    #+begin_html
    <details><summary></summary>
    #+end_html

    #+begin_src clojure :tangle src/app/fun/randomname.cljs
      (ns app.fun.randomname
        (:require [clojure.string :as string :refer [join]]))

      (def data
        {:name [:adj :noun]
         :adj  [["super" "ultra" "pro" "surprising"]]
         :noun [["node" "point" "port"]]})

      (defn pick-random [vec]
        (nth vec (.floor js/Math (rand (count vec)))))

      (defn random-name
        ([] (random-name :name 0))
        ([terminal depth]
         (let [read (data terminal)]
           (if (or (nil? read)
                   (> depth 10))
             (str terminal)
             (join "-" (for [item read]
                         (cond
                           (keyword? item) (random-name item (+ 1 depth))
                           (vector? item)  (random-name (pick-random item) (+ 1 depth))
                           :else item)))))))
    #+end_src

    + 之后需要增加更多的 =data=
    + 不过在生产中可能需要去掉... 做着玩了属于是

    #+begin_html
    </details>
    #+end_html

** Draw Board
*** Overview
绘制的整体框架如下:

#+name: stage-1-draw-board
#+begin_src clojure :noweb yes :tangle no
  ;;; Info and Data
  <<stage-1-draw-board-info>>

  ;;; Nodes
  <<stage-1-draw-node>>

  ;;; Art-board
  <<stage-1-draw-art-board>>

  (defn draw-board []
    (let [nodes DRAWED-NODES]
      (fn []
        [draw-artboard
         ^{:key :draw-arcs} [draw-arcs]
         ^{:key :draw-nodes} [draw-nodes]])))
#+end_src

其中的框架具体内容如下:

*** art-board
绘制 Art-board (作为主要的入口), 大致逻辑如下:
+ 绘制一个蒙版和背景并将蒙版叠在背景上 =rect=
+ 当背景被拖动的时候, 响应拖动事件和鼠标落下的事件
+ 绘制其他的主体
  
#+name: stage-1-draw-art-board
#+begin_src clojure :tangle no
  (defn draw-artboard [& nodes]
    ;; local closure variable
    (let [dragging? (atom false)]
      ;; predefine functions
      (let [resize-artboard  (fn [mouse]
                               (.stopPropagation mouse)
                               (reset!
                                SCALE
                                (max 10 (min 100 (+ (* 0.05 mouse.deltaY) @SCALE)))))
            start-artboard   (fn [mouse]
                               (.stopPropagation mouse)
                               (reset! SELECTED-PORT nil)
                               (condp = mouse.button
                                 0 (do
                                     (reset! INFO-PAN nil)
                                     (reset! dragging? true))
                                 2 (do
                                     (reset! INFO-PAN  {:x mouse.clientX
                                                        :y mouse.clientY
                                                        :type :add}))
                                 nil))
            moving-artboard  (fn [mouse]
                               (.stopPropagation mouse)
                               (when @dragging?
                                 (reset! TR-X (+ @TR-X mouse.movementX))
                                 (reset! TR-Y (+ @TR-Y mouse.movementY))))
            stop-artboard    (fn [mouse]
                               (reset! dragging? false))]
        (fn [node]
          [:g
           ;; Mask
           [:mask#art-board-background-mask
            [:rect {:width  (- @WIDTH @SIDE-BAR-WIDTH (* 3 10))
                    :height (- @HEIGHT 20)
                    :fill   :white
                    :stroke :black
                    :stroke-width 3}]]
           ;; Artboard
           [:g {:transform "translate(10 10)"}
            ;; background
            [:rect {:width  (- @WIDTH @SIDE-BAR-WIDTH (* 3 10))
                    :height (- @HEIGHT 20)
                    :fill   :white
                    :stroke :black
                    :stroke-width 3
                    :on-wheel       resize-artboard
                    :on-mouse-down  start-artboard
                    :on-mouse-move  moving-artboard
                    :on-mouse-leave stop-artboard
                    :on-mouse-up    stop-artboard}]
            ;; nodes
            [:g {:mask "url(#art-board-background-mask)"}
             [:g (transform :x @TR-X :y @TR-Y :s @SCALE)
              nodes]]]]))))
#+end_src

其中有一个两层的let函数分别用于声明所用的变量闭包以及内部使用的函数.
(关于为什么提前定义内部使用的函数这是为了防止在之后重新绘制节点的时候,
这是为了防止每次都需要重新执行并计算函数而浪费性能. ) 

*** draw-node-arc
绘制节点的边  
+ 绘制边的方式为一根 Bessel 曲线

#+name: stage-1-draw-node-arc  
#+begin_src clojure :tangle no
  (defn draw-node-arc [{:keys [x1 y1 x2 y2 info]}]
    (let [select-arc (fn [info mouse]
                       (reset! INFO-PAN {:x mouse.clientX
                                         :y mouse.clientY
                                         :type :arc
                                         :info info}))]
     (fn [{:keys [x1 y1 x2 y2]}]
       (let [weight (min 6 (* 0.1 (abs (- y2 y1)) (max 8 (abs (- x2 x1)))))]
         [:path {:d (str "M" x1 " " y1 " "
                         "C" (+ x1 weight) " " y1 ", "
                         (- x2 weight) " " y2 ", "
                         x2 " " y2)
                 :stroke :grey
                 :stroke-width 0.12
                 :fill :none
                 :on-click #(select-arc info %)}]))))

  (defn draw-arcs []
    (fn []
      [:g
       (doall
        (for [[from-node from-port to-node to-port] @ARCS]
          (let [x1 @(cursor NODES [from-node :pos-x])
                y1 @(cursor NODES [from-node :pos-y])
                x2 @(cursor NODES [to-node :pos-x])
                y2 @(cursor NODES [to-node :pos-y])
                [dx1 dy1] @(cursor NODES [from-node :out-pos from-port])
                [dx2 dy2] @(cursor NODES [to-node   :in-pos  to-port])]
            ^{:key (str "arc-" from-node from-port to-node to-port)}
            [draw-node-arc {:x1 (+ x1 dx1) :y1 (+ y1 dy1)
                            :x2 (+ x2 dx2) :y2 (+ y2 dy2)
                            :info [from-node from-port to-node to-port]}])))]))
#+end_src

*** draw-node
绘制节点

+ 整体
  #+name: stage-1-draw-node
  #+begin_src clojure :noweb yes :tangle no
    ;;; Draw nodes
    <<stage-1-draw-node-arc>>
    <<stage-1-draw-node-port>>
    <<stage-1-draw-node-body>>

    (defn draw-node [id node]
      (fn []
        (let [x (get-in @NODES [id :pos-x])
              y (get-in @NODES [id :pos-y])]
          [:g
           ;; draw body
           ^{:key (str id "body")} [draw-node-body id {:x x :y y}]

           ;; draw in port
           (for [[port [dx dy]] (node :in-pos)]
             ^{:key (str id "in" port)} [draw-node-port {:id   id
                                                         :port port
                                                         :x    (+ x dx)
                                                         :y    (+ y dy)}])

           ;; draw out port
           (for [[port [dx dy]] (node :out-pos)]
             ^{:key (str id "out" port)} [draw-node-port {:id   id
                                                          :port port
                                                          :x    (+ x dx)
                                                          :y    (+ y dy)}])])))

    (defn draw-nodes []
      (fn []
        [:g
         (for [[id node] @NODES]
          ^{:key (str "node" id)} [draw-node id node])]))
  #+end_src
+ 绘制节点主体
  
  #+name: stage-1-draw-node-body
  #+begin_src clojure :tangle no
    (defn draw-node-body [id {:keys [x y]}]
      (let [node-moved (atom false)]
        (let [start-move (fn [node mouse]
                           (condp = mouse.button
                             0 (do          ; left click: MOVE NODE
                                 (reset! node-moved false)
                                 (reset! INFO-PAN nil)
                                 (reset! SELECTED-ID node))
                             2 (do          ; right click: OPEN INFO-PAN
                                 (reset! INFO-PAN {:x mouse.clientX
                                                   :y mouse.clientY
                                                   :type :node
                                                   :info node}))
                             '()))
              move-node  (fn [id mouse]
                           (when (= id @SELECTED-ID)
                             (reset! node-moved true)
                             (reset!
                              NODES
                              (-> @NODES
                                  (update-in [id :pos-x]
                                             #(+ % (/ mouse.movementX @SCALE)))
                                  (update-in [id :pos-y]
                                             #(+ % (/ mouse.movementY @SCALE)))))))
              end-move   (fn [node mouse]
                           (reset! SELECTED-ID nil)
                           (when (and (= mouse.movementX 0)
                                      (= mouse.movementY 0)
                                      node
                                      (not @node-moved))
                             (reset! INFO-PAN {:x mouse.clientX
                                               :y mouse.clientY
                                               :type :node
                                               :info node})
                             (reset! node-moved false)))]
          (fn [id {:keys [x y]}]
            [:g (conj (transform :x x :y y)
                      {
                       :on-mouse-down  #(start-move id %)
                       :on-mouse-move  #(move-node id %)
                       :on-mouse-leave #(end-move false %)
                       :on-mouse-up    #(end-move id %)})
             [:rect {:width 1
                     :height 1
                     :fill @(cursor NODES [id :color])}]
             [:text {:x 0
                     :y -0.05
                     :font-size 0.3}
              @(cursor NODES [id :name])]]))))
  #+end_src
+ 绘制节点的接口

  在 =NODES= 中的数据记录的 =in-pos=, =out-pos= 的形式为
  ={:port-name [port-relative-x port-relative-y]}=.
  使用相对位移的方式来进行绘制端口相对节点 (右上角) 的位置.


  #+name: stage-1-draw-node-port
  #+begin_src clojure
    (defn draw-node-port [{:keys [id port x y]}]
      (let [select-port (fn [node-id port-id mouse]
                          (condp = mouse.button
                            0 (if (nil? @SELECTED-PORT)
                                (reset! SELECTED-PORT [node-id port-id])
                                (let [[id2 port2] @SELECTED-PORT]
                                  (reset! SELECTED-PORT nil)
                                  (add-arc id2 port2 node-id port-id)))
                            nil))]

       (fn [{:keys [x y]}]
         [:circle {:cx x
                   :cy y
                   :r  0.12
                   :stroke :black
                   :stroke-width 0.05
                   :fill (let [[node-id port-id] @SELECTED-PORT]
                           (if (and (= node-id id)
                                    (= port-id port))
                             :orange
                             :white))
                   :on-mouse-down #(select-port id port %)}])))
  #+end_src
  
** Sidebar
绘制 Side-bar: 用于表现项目的树状关系, 进行更多的处理等工作.

+ 在侧边栏中的功能, 嗯, 目前就用做调试用吧. 

#+name: stage-1-draw-side-bar
#+begin_src clojure :noweb yes :tangle no
  <<stage-1-draw-sidebox-dbg>>

  (defn draw-side-bar []
    (let [drag? (atom false)]
      (let [mouse-down #(reset! drag? true)
            mouse-leave #(reset! drag? false)
            mouse-move (fn [mouse]
                         (when @drag?
                           (if (< @SIDE-BAR-WIDTH 100)
                             (reset! SIDE-BAR-WIDTH 100)
                             (swap! SIDE-BAR-WIDTH - mouse.movementX))))]
        (fn []
          (let [sidebox [:rect {:width @SIDE-BAR-WIDTH
                                :height (- @HEIGHT 20)
                                :fill :white
                                :stroke :black
                                :stroke-width 3}]]
            [:g (transform :x (- @WIDTH @SIDE-BAR-WIDTH 20)
                           :y 10)
             [:rect {:width 10
                     :height (- @HEIGHT 20)
                     :fill :transparent
                     :stroke :none
                     :on-mouse-down mouse-down
                     :on-mouse-move mouse-move
                     :on-mouse-leave mouse-leave
                     :on-mouse-up mouse-leave}]
             [:g (transform :x 10 :y 0)
              [:mask.sidebox-mask sidebox]
              [:g {:mask "url(#sidebox-mask)"}
               sidebox
               [draw-sidebox-dbg]]]])))))
#+end_src

*** draw-sidebox-dbg
#+name: stage-1-draw-sidebox-dbg
#+begin_src clojure :tangle no
  (defn draw-sidebox-dbg []
    (fn []
      [:g
       [:foreignObject {:width @SIDE-BAR-WIDTH
                        :height (- @HEIGHT 20)}
        [:div
         [:h1 "Bad DBG"]

         (doall
          (for [[idx id] (map-indexed vector @EVAL-NODE-QUEUE)]
            ^{:key (str idx "sidebar-" id)} [:li @(cursor NODES [id :name])]))]]
       [:g (transform :x 10 :y (- @HEIGHT 60))
        ^{:key :sidebox-dbg-eval-graph} [:rect {:width 30
                                                :height 30
                                                :fill :green
                                                :stroke :black
                                                :stroke-width "2px"
                                                :on-click eval-graph}]
        ^{:key :sidebox-dbg-eval-graph-init} [:rect {:width 30
                                                        :height 30
                                                        :x 40
                                                        :fill :yellow
                                                        :stroke :black
                                                        :stroke-width "2px"
                                                        :on-click eval-graph-initial}]
        ^{:key :sidebox-dbg-eval-graph-step} [:rect {:width 30
                                                     :height 30
                                                     :x 80
                                                     :fill :red
                                                     :stroke :black
                                                     :stroke-width "2px"
                                                     :on-click eval-graph-stepper}]]]))
#+end_src

** Info-pan
绘制 Info-pan: 用于展示节点的信息, 添加或者删除节点等进行交互的工作. 

#+name: stage-1-draw-info-pan
#+begin_src clojure :noweb yes :tangle no
  <<stage-1-draw-pan-helper>>
  <<stage-1-draw-add-pan>>
  <<stage-1-draw-node-pan>>
  <<stage-1-draw-arc-pan>>

  (defn draw-info-pan []
    (let [width  150
          height 200
          rect   [:rect {:width  width
                         :height height
                         :fill   :white
                         :fill-opacity 0.5
                         :stroke :black
                         :stroke-width 2}]]
      (fn []
        (when-not (nil? @INFO-PAN)        ; draw when INFO-PAN is triggered
          (let [{:keys [type x y info]} @INFO-PAN]
            [:g (transform :x x :y y)
             [:mask#info-pan-mask rect]
             rect
             [:foreignObject {:mask "url(info-pan-mask)"
                              :width width
                              :height height}
              [:div {:style {:overflow-y :scroll
                             :width "100%"
                             :height "100%"
                             :margin 0
                             :padding 0}}
               (condp = type
                 :add  ^{:key info} [draw-add-pan info]
                 :node ^{:key info} [draw-node-pan info]
                 :arc  ^{:key info} [draw-arc-pan info]
                 nil)]]])))))
#+end_src
+ 为了方便绘制元素, 将一些共同的元素进行打包:

  #+name: stage-1-draw-pan-helper
  #+begin_src clojure :noweb yes :tangle no
    <<stage-1-draw-pan-button>>
    <<stage-1-draw-pan-split>>
    <<stage-1-draw-pan-form>>
    <<stage-1-draw-pan-title>>
  #+end_src
  + 绘制标题

    #+name: stage-1-draw-pan-title
    #+begin_src clojure :tangle no
      (defn draw-pan-title [attrs]
        (fn [attrs]
          [:div.info-title {:style {:background (or (attrs :color) :grey)
                                    :padding "5px"}}
           (attrs :label)]))
    #+end_src

    注: 这里缺少一些 CSS 特效...
    目前的想法是:
    + 尝试实现一个背景透明
    + 或者实现字体颜色自动变化
  + 绘制分割符

    #+name: stage-1-draw-pan-split
    #+begin_src clojure :tangle no
      (defn draw-pan-split [attrs]
        (fn [attrs]
          [:div.info-split {:style {:padding-top "5px"
                                    :padding-bottom "2px"
                                    :padding-left "5px"
                                    :padding-right "5px"}}
           [:span.info-split-label (attrs :label)]
           [:hr.info-split-hr {:style {:margin-top "1px"
                                       :margin-bottom "0px"}}]]))
    #+end_src
  + 绘制表单

    #+name: stage-1-draw-pan-form
    #+begin_src clojure :tangle no
      (defn draw-pan-form [attrs]
        (let [nop #()]
          (fn [attrs]
            [:div.info-item {:style {:margin-top "3px"
                                     :margin-left "2px"
                                     :margin-right "2px"}}
             [:span.info-label {:style {:width "30%"
                                        :padding "2px"
                                        :margin "0"
                                        :margin-right "3px"}}
              (attrs :label)]
             [:input.info-input {:style {:width "50%"
                                         :padding "2px"
                                         :margin "0"}
                                 :placeholder (or (attrs :placeholder) "")
                                 :value (or (attrs :value) "")
                                 :disabled (boolean (attrs :disabled))
                                 :on-blur (or (attrs :on-blur) nop)
                                 :on-key-press (or (attrs :on-key-press) nop)
                                 :on-change (or (attrs :on-change) nop)}]])))
    #+end_src
  + 绘制按钮
    
    #+name: stage-1-draw-pan-button
    #+begin_src clojure :tangle no
      (defn draw-pan-button [attrs]
        (fn [attrs]
          [:center.info-button-wrapper {:style {:padding "5px"}}
           [:button.info-button {:style {:width "100%"}
                                 :on-click (attrs :on-click)}
            (attrs :label)]]))
    #+end_src
+ 绘制添加节点的表单
    
  #+name: stage-1-draw-add-pan
  #+begin_src clojure :tangle no
    (defn draw-add-pan [info]
      (let [search (atom (random-name))]
        (let [rand-name-fun #(reset! search (random-name))
              update-value #(reset! search (-> % .-target .-value))
              make-new-node (fn [type mouse]
                              (let [x (/ (- mouse.clientX @TR-X) @SCALE)
                                    y (/ (- mouse.clientY @TR-Y) @SCALE)]
                                (reset! INFO-PAN nil)
                                (add-node {:name @search
                                           :type type
                                           :x x
                                           :y y})))]
         (fn []
           [:div
            [draw-pan-title {:color "#CCC"
                             :label "Add Node"}]
            ^{:key :info-pan-form-split} [draw-pan-split {:label "Node Name"}]
            [draw-pan-form {:label "name"
                            :value @search
                            :on-change update-value}]

            ^{:key :info-pan-class-split} [draw-pan-split {:label "Classes"}]
            (for [[type _] @CLASS]
              ^{:key (str "i-p-s-" type)}
              [:div.type-select {:style {:padding "3px"}
                                 :on-click #(make-new-node type %)}
               (str type)])]))))
  #+end_src
+ 绘制节点信息表单
    
  #+name: stage-1-draw-node-pan
  #+begin_src clojure :tangle no
    (defn draw-node-pan [info]
      (let [update      (fn [node type arg input]
                          (swap!
                           (cursor NODES [node type])
                           #'assoc arg
                           (-> input .-target .-value)))
            delete-node (fn [node]
                          (reset! INFO-PAN nil)
                          (del-node node))
            enter-press (fn [node select arg key]
                          (condp = key.charCode
                            13  (let [val (cursor NODES [node select arg])]
                                  (when (string? @val) (reset! val (parse @val)))
                                  (eval-node node))
                            nil))
            lose-focus  (fn [node select arg]
                          (let [val (cursor NODES [node select arg])]
                            (when (string? @val)
                              (reset! val (parse @val)))))]
        (fn [info]
          (let [{:keys [param in out color name]} @(cursor NODES [info])]
            [:div
             ;; Title
             [draw-pan-title {:color color
                              :label name}]

             ;; Parameters
             ^{:key :info-pan-param-split} [draw-pan-split {:label "Parameters"}]

             (doall
              (for [[arg val] param]
                ^{:key (str "info-p-" arg)}
                [draw-pan-form {:label arg
                                :placeholder val
                                :value val
                                :on-blur #(lose-focus info :param arg)
                                :on-key-press #(enter-press info :param arg %)
                                :on-change #(update info :param arg %)}]))

             ;; Inputs
             ^{:key :info-pan-in-split} [draw-pan-split {:label "Inputs"}]

             (doall
              (for [[arg val] in]
                ^{:key (str "info-i-" arg)}
                [draw-pan-form {:label arg
                                :placeholder val
                                :value val
                                :on-blur #(lose-focus info :in arg)
                                :on-key-press #(enter-press info :in arg %)
                                :on-change #(update info :in arg %)}]))

             ;; Results
             ^{:key :info-pan-val-split} [draw-pan-split {:label "Results"}]

             (doall
              (for [[arg val] out]
                ^{:key (str "info-v-" arg)}
                [draw-pan-form {:label arg
                                :disabled true
                                :value val}]))

             ;; Delete Node Button
             [draw-pan-button {:on-click #(delete-node info)
                               :label "Delete Node"}]]))))
  #+end_src
+ 绘制边表单

  #+name: stage-1-draw-arc-pan
  #+begin_src clojure :tangle no
    (defn draw-arc-pan [info]
      (let [delete (fn [from-node from-port to-node to-port]
                     (reset! INFO-PAN nil)
                     (delete-arc from-node from-port to-node to-port))]
        (fn [info]
          (let [[from-node from-port to-node to-port] info]
            [:div
             [draw-pan-title {:label (str from-port "->" to-port)}]

             [draw-pan-button {:label "Delete Arc"
                               :on-click #(delete from-node from-port to-node to-port)
                               }]]))))
  #+end_src
* Stage 2 - Logic and Evaluate
** Input Parser
#+begin_src clojure :tangle src/app/parser/core.cljs
  (ns app.parser.core
    (:require [instaparse.core        :as insta :refer-macros [defparser]]
              [clojure.string         :as str]
              [sci.core               :as sci]
              [emmy.env               :as math]
              [emmy.expression.render :as exp-render]))
#+end_src

将输入经过 Parser 转换为一个 ClojureScript 能够读取的数值类型,
目前实现的是一个能够处理简单四则运算的功能. 之后需要加入的功能:
+ [x] 符号表示
+ [x] 简单函数

一个简单的演示:

[[./img/sym-demo-5-24.gif]]
  
其中实现上述功能使用的基础数学符号计算包为 [[https://github.com/mentat-collective/emmy][emmy]],
为了能够简单运行代码, 使用了 [[https://github.com/babashka/sci][sci]] 库作为 =eval= 的替代品.
不过目前还有的不足:
+ 输入没有提示, 语法检查没有任何的提示
+ 输入没有安全检查, 可能会输入恶意脚本
+ 输入并不是很智能

*** 定义语法规则
简单的语法规则如下所示 (使用 EBNF 来表示):

#+begin_src clojure :tangle src/app/parser/core.cljs
  ;;; EBNF Rules for Simple Input
  ;;; Calculator EBNF
  (def ebnf
    "EXPR     = POWER;
     POWER    = MUL (SPLIT '^' SPLIT MUL)*;
     MUL      = SUM (SPLIT ('*' | '/') SPLIT SUM)*;
     SUM      = CMP (SPLIT ('+' | '-') SPLIT CMP)*;
     CMP      = VALUE (SPLIT ('<' | '<=' | '=' | '>=' | '>') SPLIT VALUE)*;
     VALUE    = SPLIT ELEMENT SPLIT | SPLIT '(' SPLIT EXPR SPLIT ')' SPLIT;
     ELEMENT  = LAMBDA | FUNC | FUNC-F | SYMBOL-V | NUMBER | EXPR;
     LAMBDA   = ('λ' | 'lambda' | 'fn') '(' SPLIT LIST-V SPLIT ').(' EXPR ')';
     FUNC     = SYMBOL-F '(' SPLIT ?[LIST-E] SPLIT ')'
     FUNC-F   = '(' SPLIT EXPR SPLIT ')(' SPLIT ?[LIST-E] SPLIT ')';
     LIST-V   = SYMBOL (SPLIT ',' SPLIT SYMBOL)*
     LIST-E   = ELEMENT (SPLIT ',' SPLIT ELEMENT)*
     SYMBOL-F = SYMBOL;
     SYMBOL-V = SYMBOL;
     SYMBOL   = #\"[a-zA-Z][a-zA-Z\\-]*\\??\";
     SPLIT    = #\"\\s*\";
     NUMBER   = #\"[0-9]+(\\.[0-9]*)?|[0-9]*\\.[0-9]+\";
  ")
#+end_src

这个语法规则构建得有够难看的...

*** 简单的 Parser 和处理程序
#+begin_src clojure :tangle src/app/parser/core.cljs
  ;;; Raw parse
  (defparser parse->ebnf-struct ebnf)

  (defn ebnf-struct->ast [ast & {:keys [unquote] :or {unquote false}}]
    (let [arg (nth ast 1)
          args (rest ast)
          reduce-by (fn [ops content]
                      (loop [idx 4
                             val (ebnf-struct->ast arg :unquote unquote)]
                        (if (< idx (count content))
                          (recur
                           (+ idx 4)
                           (list (ops (nth content (- idx 2)))
                                 val
                                 (ebnf-struct->ast (nth content idx) :unquote unquote)))
                          val)))]
      (condp = (first ast)
        :EXPR     (ebnf-struct->ast arg :unquote unquote)
        :CMP      (reduce-by {"<"  '<
                              ">"  '>
                              ">=" '>=
                              "="  '=
                              "<=" '<=} args)
        :SUM      (reduce-by {"+" '+
                              "-" '-} args)
        :MUL      (reduce-by {"*" '*
                              "/" '/} args)
        :POWER    (reduce-by {"^" 'expt} args)
        :VALUE    (if (= (count args) 3)
                    (ebnf-struct->ast (nth args 1) :unquote unquote)
                    (ebnf-struct->ast (nth args 3) :unquote unquote))
        :ELEMENT  (ebnf-struct->ast arg :unquote unquote)
        :NUMBER   (js/Number arg)
        :SYMBOL   (symbol arg)
        :LAMBDA   (list 'fn (vec (ebnf-struct->ast (nth args 3) :unquote unquote))
                        (ebnf-struct->ast (nth args 6) :unquote true))
        :FUNC     (if (= (count args) 4)
                    (list (ebnf-struct->ast arg :unquote unquote))
                    (cons (ebnf-struct->ast arg :unquote unquote)
                          (ebnf-struct->ast (nth args 2) :unquote unquote)))
        :FUNC-F   (if (= (count args) 7)
                    (list (ebnf-struct->ast (nth args 2) :unquote unquote))
                    (cons (ebnf-struct->ast (nth args 2) :unquote unquote)
                          (ebnf-struct->ast (nth args 5) :unquote unquote)))
        :SYMBOL-F (ebnf-struct->ast arg)
        :SYMBOL-V (if unquote
                    (ebnf-struct->ast arg :unquote unquote)
                    (list 'quote (ebnf-struct->ast arg :unquote unquote)))
        :LIST-E   (map #(ebnf-struct->ast % :unquote unquote)
                       (map #'first (partition-all 4 args)))
        :LIST-V   (map #(ebnf-struct->ast % :unquote unquote)
                       (map #'first (partition-all 4 args)))
        nil)))
#+end_src

*** 计算
计算环境设置:

#+begin_src clojure :tangle src/app/parser/core.cljs
  (def math-ctx (let [emmy-ns (sci/create-ns 'clojure.core)
                      namespace (sci/copy-ns emmy.env emmy-ns)]
                  (sci/init {:namespaces {'clojure.core namespace}})))
#+end_src

计算程序主体:

#+begin_src clojure :tangle src/app/parser/core.cljs
  (defn calculate [input]
    (let [ast (-> input (parse->ebnf-struct) (ebnf-struct->ast))]
      (if (= 'bad-input ast)
        'bad-input
        (try
          (sci/eval-form math-ctx ast)
          (catch js/Error e (println e) 'bad-calculation)))))
#+end_src

*** 格式化输出
#+begin_src clojure :tangle src/app/parser/core.cljs
  (def exp->raw
    (exp-render/make-infix-renderer   
     :precedence-map '{<  1
                       <= 1
                       =  1
                       >= 1
                       >  1
                       +  2
                       -  2
                       ,*  3
                       /  3
                       expt 4}
     :infix? '{+ - * / expt < <= = >= >}
     :special-handlers {'/ (fn [[num denom :as xs]]
                             (if (= 1 (count xs))
                               (str "1 / " num)
                               (str num " / " denom)))}))
#+end_src

需要修改的工作:
+ [ ] 对 =lambda= 函数的格式化输出,
  但是因为原则上目前用户应该不会使用这个,
  所以暂时先不管了.

*** 外部调用
在其他程序中, 引用 =parse= 函数将输入放入即可.

#+begin_src clojure :tangle src/app/parser/core.cljs
  (defn parse "Parse Input." [input]
    (try
      (exp->raw (calculate input))
      (catch js/Error e (println e) "")))
#+end_src

** Node Evaluate
运算单个节点:
+ 将 =param=, =in= 作为计算环境
  + =param= 是节点的内置属性
  + =in= 是节点的外部输入, 在没有输入的时候, 可以手动填充
+ 调用 =CLASS= 的 =func= 在环境中进行计算
+ 将计算后的结果作为 =out= 进行储存

#+name: stage-2-eval-node
#+begin_src clojure :noweb yes :tangle no
  (defn eval-node [id]
    (let [class (cursor NODES [id :class])
          in    (cursor NODES [id :in])
          param (cursor NODES [id :param])
          out   (cursor NODES [id :out])
          map-h (fn [f kvs] (into {} (map (fn [[k v]] [k (f v)]) kvs)))]
      (let [func (cursor CLASS [@class :func])]
        ;; update-node-input
        (doseq [[port _] @in]
          (doseq [[from-node from-port _ _] (find-arc {:to-node id :to-port port})]
            (swap! in assoc port @(cursor NODES [from-node :out from-port]))))

        ;; eval out
        (reset! out (map-h #'parser/exp->raw
                           (@func (conj (map-h #'parse @in)
                                        (map-h #'parse @param))))))))

  <<stage-2-eval-graph>>
#+end_src

计算整个图, 不过为了方便分析, 这里将计算整个图的函数拆分成如下的部分:

#+name: stage-2-eval-graph
#+begin_src clojure :noweb yes :tangle no
  (defonce EVAL-NODE-QUEUE (atom []))

  <<stage-2-eval-graph-initial>>
  <<stage-2-eval-graph-stepper>>

  (defn eval-graph []
    (eval-graph-initial)
    (while (not (empty? @EVAL-NODE-QUEUE))
      (eval-graph-stepper)))
#+end_src

+ 启动函数: 将所有的 =Input= 类型的节点放入执行队列 =EVAL-NODE-QUEUE= 中:

  #+name: stage-2-eval-graph-initial
  #+begin_src clojure :tangle no
    (defn eval-graph-initial []
      (reset! EVAL-NODE-QUEUE
              (->> @NODES
                   (filter (fn [[_ {class :class}]] (= class :Input)))
                   (map (fn [[id _]] id)))))
  #+end_src
+ 单步执行函数: 从 =EVAL-NODE-QUEUE= 中按照先入先出的逻辑取一个节点进行计算

  #+name: stage-2-eval-graph-stepper
  #+begin_src clojure :tangle no
    (defn eval-graph-stepper []
      (when-not (empty? @EVAL-NODE-QUEUE)
        (let [[node & rest] @EVAL-NODE-QUEUE]
          (eval-node node)
          (reset! EVAL-NODE-QUEUE
                  (concat rest
                          (map (fn [[_ _ from _]] from)
                               (find-arc {:from-node node})))))))
  #+end_src
** File Open and Save
这里需要一些对 =src/app/main/core.cljs= 进行修改,
增加如下的代码:

#+begin_src clojure :tangle no
  ;;; File read and write
  (defn read-file [path]
    (.readFileSync fs path "utf8"))

  (defn write-file [path content]
    (.writeFileSync fs path content))

  ;;; Regist IPC event
  (.on ipc-main "read-file" (fn [event path]
                              (let [data (read-file path)]
                                (.send event "file-data" data))))

  (.on ipc-main "write-file" (fn [event path content]
                               (write-file path content)
                               (.send event "file-saved")))
#+end_src

于是在 =renderer= 进程中, 就可以通过 =ipc-render= 来进行事件调用,
来将文件进行保存之类的操作:

* COMMENT LocalWords
#  LocalWords: LocalWords magit svg cljs noweb TODO dbg sidebox EBNF
